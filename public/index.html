<!DOCTYPE html>
<html lang="en">
<head>
    <title>File System</title>
    <link rel="stylesheet" type="text/css" href="/styles.css">
</head>
<body>

<div class="container">

    <h2>File System</h2>

    <ul id="breadcrumb" class="breadcrumb">

    </ul>

    <button class="btn_prev" onclick="changePage(-1)">Previous</button>
    <button class="btn_next" onclick="changePage(1)">Next</button>

    <span style="float:right;" id="txt_page">Page: </span>

    <span class="limit">
        <label for="input_limit">Limit: </label>
        <input type="number" min="1" id="input_limit" oninput="updateLimit()">
    </span>

    <br><br>

    <table id="file-table">

        <thead>
        <tr>
            <th></th>
            <th style="width:50%;" onclick="sortTable('name')">
                Name
                <img id="img_name" class="arrow" src="img/expand_less.png">
            </th>
            <th style="width:25%" onclick="sortTable('date')">
                Date Modified
                <img id="img_date" class="arrow" src="img/expand_less.png">
            </th>
            <th onclick="sortTable('type')">
                Type
                <img id="img_type" class="arrow" src="img/expand_less.png">
            </th>
            <th onclick="sortTable('size')">
                Size
                <img id="img_size" class="arrow" src="img/expand_less.png">
            </th>
            <th style="cursor: default">Action</th>
        </tr>
        </thead>

        <tbody id="file-table-body">

        </tbody>

    </table>

    <br>
    <button class="btn_prev" onclick="changePage(-1)">Previous</button>
    <button class="btn_next" onclick="changePage(1)">Next</button>

    <br>
    <br>
    <button onclick="zipItems()">Download selected items as .zip</button>

</div>

<script>
    const baseURL = "http://localhost:1234";
    const homeName = "File System";
    let currentPath = homeName;

    let sortOrder = {
        name: 'dsc',
        date: 'dsc',
        type: 'asc',
        size: 'asc'
    };

    let lastClickedIndex = -1;
    let page = 1;
    const limitInput = document.getElementById("input_limit");
    limitInput.value = "5";

    window.addEventListener('load', goHome);

    async function fetchData(url) {
        const response = await fetch(url);
        return response.json();
    }

    /**
     * Change the directory to root directory of the file system
     * */
    async function goHome() {
        currentPath = homeName;
        page = 1;
        const data = await fetchData(baseURL + `/home?page=${page}&limit=${limitInput.value}`);
        updateUI(data);
    }

    /**
     * Change the directory to the specified argument, which is a child directory of the current path
     * */
    async function changeDir(folderName) {
        currentPath = `${currentPath}/${folderName}`;
        page = 1;
        const data = await fetchData(baseURL + `/dir?url=${currentPath}&page=${page}&limit=${limitInput.value}`);
        updateUI(data);
    }

    // Remove last directory from path
    function removeOneDir(path) {
        const pathParts = path.split('/');
        return pathParts.slice(0, -1).join('/');
    }

    /**
     * Change the directory to the parent directory of the current path
     * */
    async function goUp() {
        const newPath = removeOneDir(currentPath);
        currentPath = newPath;
        page = 1;
        const data = await fetchData(baseURL + `/dir?url=${newPath}&page=${page}&limit=${limitInput.value}`);
        updateUI(data);
    }

    async function goTo(path) {
        currentPath = path;
        page = 1;
        const data = await fetchData(baseURL + `/dir?url=${path}&page=${page}&limit=${limitInput.value}`);
        updateUI(data);
    }

    /**
     * Increase or decrease the page number
     * @param change number to add to page number
     */
    async function changePage(change) {
        page += change;
        const data = await fetchData(baseURL + `/dir?url=${currentPath}&page=${page}&limit=${limitInput.value}`);
        updateUI(data);
    }

    /**
     * When the 'Limit' input text box is changed, update the page
     */
    async function updateLimit() {
        const data = await fetchData(baseURL + `/dir?url=${currentPath}&page=${page}&limit=${limitInput.value}`);
        updateUI(data);
    }

    /**
     * Calls all functions that update the page
     * @param data JSON response
     */
    function updateUI(data) {
        updateTable(data);
        updatePagination(data);
        updateBreadcrumb();
    }

    /**
     * Clear the <tbody> element and add new rows from the JSON data received returned after making a GET request
     * */
    function updateTable(data) {
        const tableBody = document.getElementById('file-table-body');
        tableBody.innerHTML = '';

        for (const item of data.results) {
            const row = tableBody.insertRow(-1);
            const cell1 = row.insertCell(0); // Checkboxes
            const cell2 = row.insertCell(1); // Name
            const cell3 = row.insertCell(2); // Date Modified
            const cell4 = row.insertCell(3); // Type
            const cell5 = row.insertCell(4); // Size
            const cell6 = row.insertCell(5); // Action

            // If the item name is not '..', then add a checkbox
            cell1.innerHTML = item.name !== '..' ? `<input type="checkbox" value="${item.name}">` : '';

            if (item.name === '..') {
                cell2.innerHTML = `<div><img class="parent_icon" src="img/folder_up.png" onclick="goUp()"><a href="#" onclick="goUp()">[parent directory]</a></div>`;
            } else if (item.type === "Folder") {
                cell2.innerHTML = `<a href="#" onclick="changeDir('${item.name}')">${item.name}</a>`;
            } else if (item.type === "File") {
                cell2.innerHTML = item.name;
            }

            cell3.innerHTML = item.date;
            cell4.innerHTML = item.type;

            if (item.type === "File") {
                cell5.innerHTML = item.size;
                cell6.innerHTML = `<button onclick="window.location.href='/download?filepath=${item.url}'">Download</button>`;
            }
        }

        let checkboxes = document.querySelectorAll('input[type="checkbox"]');

        for (let i = 0; i < checkboxes.length; i++) {
            const checkbox = checkboxes[i];
            checkbox.addEventListener('click', event => handleCheckboxClick(event, i));
        }

    }

    const nextButtons = document.getElementsByClassName("btn_next");
    const prevButtons = document.getElementsByClassName("btn_prev");
    const pageText = document.getElementById("txt_page");

    /**
     * Enable or disable the 'Next' and 'Previous' buttons depending on number of page results
     * @param data JSON response
     */
    function updatePagination(data) {
        for (let button of nextButtons) {
            button.disabled = !data.hasOwnProperty("next");
        }
        for (let button of prevButtons) {
            button.disabled = !data.hasOwnProperty("prev");
        }
        pageText.innerHTML = `Page: ${page}/${data.totalPages}`;
    }

    /**
     *  Updates the breadcrumb in the page to match the current path.
     */
    function updateBreadcrumb() {
        let breadcrumb = document.getElementById("breadcrumb");

        breadcrumb.innerHTML = '';

        let paths = currentPath.split('/');

        for (let i = 0; i < paths.length; i++) {

            let p = currentPath;

            for (let j = paths.length - 1; j > i; j--) {
                p = removeOneDir(p);
            }

            breadcrumb.innerHTML += `<li><a href="#" onclick="goTo('${p}')">${paths[i]}</a></li>`;
        }
    }

    /**
     * Enable shift-clicking to select multiple checkboxes at one go
     */
    function handleCheckboxClick(event, currentIndex) {
        let checkboxes = document.querySelectorAll('input[type="checkbox"]');

        if (event.shiftKey && lastClickedIndex !== -1) {
            const minIndex = Math.min(currentIndex, lastClickedIndex);
            const maxIndex = Math.max(currentIndex, lastClickedIndex);

            for (let i = minIndex + 1; i < maxIndex; i++) {
                checkboxes[i].checked = true;
            }
        }

        lastClickedIndex = currentIndex;
    }

    /**
     * Gets all selected checkboxes, appends their value(name) to the current path and make a get request
     * to the /zip resource with them as parameters.
     */
    function zipItems() {
        const checkboxes = document.querySelectorAll('input[type="checkbox"]:checked');
        const selectedItems = [];

        for (let i = 0; i < checkboxes.length; i++) {
            if (checkboxes[i].checked) {
                selectedItems.push(`${currentPath}/${checkboxes[i].value}`);
            }
        }

        window.location.href = `/zip?files=${selectedItems.join()}`;
    }

    function sortTable(column) {
        const tableBody = document.getElementById('file-table-body');
        const rows = Array.from(tableBody.rows);
        const image = document.getElementById('img_' + column);

        // Sort rows based on the column clicked
        rows.sort((rowA, rowB) => {
            let cellA, cellB;
            switch (column) {
                case 'name':
                    cellA = rowA.cells[1].textContent.trim();
                    cellB = rowB.cells[1].textContent.trim();
                    break;
                case 'date':
                    cellA = new Date(rowA.cells[2].textContent.trim());
                    cellB = new Date(rowB.cells[2].textContent.trim());
                    break;
                case 'type':
                    cellA = rowA.cells[3].textContent.trim();
                    cellB = rowB.cells[3].textContent.trim();
                    break;
                case 'size':
                    cellA = parseInt(rowA.cells[4].textContent.trim());
                    cellB = parseInt(rowB.cells[4].textContent.trim());
                    break;
            }

            if (sortOrder[column] === 'asc') {
                image.src = "img/expand_less.png";
                return cellA > cellB ? 1 : -1;
            } else {
                image.src = "img/expand_more.png";
                return cellA < cellB ? 1 : -1;
            }
        });

        // Change the sort order for the next click on the same column
        sortOrder[column] = sortOrder[column] === 'asc' ? 'desc' : 'asc';

        // Append sorted rows to tbody
        for (const row of rows) {
            tableBody.appendChild(row);
        }
    }

</script>

</body>
</html>